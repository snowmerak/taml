package generator

import (
	"errors"
	"strings"

	"github.com/snowmerak/tson/lib/analyzer"
)

func GoVarFromJSON(parant string, m analyzer.Member) (string, error) {
	sb := strings.Builder{}
	sb.WriteString("\tcase \"")
	sb.WriteString(m.Name)
	sb.WriteString("\":\n")
	sb.WriteString("\t")
	switch m.Type {
	case "string":
		sb.WriteString("_, val, nxt, err := jsstring.Find(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = string(val)\n")
	case "int", "int8", "int16", "int32", "int64":
		sb.WriteString("_, val, nxt, err := jsnumber.Find(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tparsed, err := strconv.ParseInt(string(val), 10, 64)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = ")
		sb.WriteString(m.Type)
		sb.WriteString("(parsed)\n")
	case "uint", "uint8", "uint16", "uint32", "uint64":
		sb.WriteString("_, val, nxt, err := jsnumber.Find(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tparsed, err := strconv.ParseUint(string(val), 10, 64)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = ")
		sb.WriteString(m.Type)
		sb.WriteString("(parsed)\n")
	case "float32", "float64":
		sb.WriteString("_, val, nxt, err := jsnumber.Find(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tparsed, err := strconv.ParseFloat(string(val), 64)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = ")
		sb.WriteString(m.Type)
		sb.WriteString("(parsed)\n")
	case "bool":
		sb.WriteString("_, val, nxt, err := jsbool.Find(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tparsed, err := strconv.ParseBool(string(val))\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = ")
		sb.WriteString(m.Type)
		sb.WriteString("(parsed)\n")
	case "[]string":
		sb.WriteString("_, array, nxt, err := jsvalues.FindArray(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := []string{}\n")
		sb.WriteString("\tfor len(array) > 0 {\n")
		sb.WriteString("\t\t_, val, nxtArr, err := jsstring.Find(array)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals = append(vals, strings.Trim(string(val), \"\\\"\"))\n")
		sb.WriteString("\t\tarray = nxtArr\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = array\n")
	case "[]int", "[]int8", "[]int16", "[]int32", "[]int64":
		sb.WriteString("_, array, nxt, err := jsvalues.FindArray(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := []")
		sb.WriteString(m.Type[2:])
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(array) > 0 {\n")
		sb.WriteString("\t\t_, val, nxtArr, err := jsnumber.Find(array)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparsed, err := strconv.ParseInt(string(val), 10, 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals = append(vals, ")
		sb.WriteString(m.Type[2:])
		sb.WriteString("(parsed))\n")
		sb.WriteString("\t\tarray = nxtArr\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = array\n")
	case "[]uint", "[]uint8", "[]uint16", "[]uint32", "[]uint64":
		sb.WriteString("_, array, nxt, err := jsvalues.FindArray(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := []")
		sb.WriteString(m.Type[2:])
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(array) > 0 {\n")
		sb.WriteString("\t\t_, val, nxtArr, err := jsnumber.Find(array)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparsed, err := strconv.ParseUint(string(val), 10, 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals = append(vals, ")
		sb.WriteString(m.Type[2:])
		sb.WriteString("(parsed))\n")
		sb.WriteString("\t\tarray = nxtArr\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = array\n")
	case "[]float32", "[]float64":
		sb.WriteString("_, array, nxt, err := jsvalues.FindArray(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := []")
		sb.WriteString(m.Type[2:])
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(array) > 0 {\n")
		sb.WriteString("\t\t_, val, nxtArr, err := jsnumber.Find(array)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparsed, err := strconv.ParseFloat(string(val), 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals = append(vals, ")
		sb.WriteString(m.Type[2:])
		sb.WriteString("(parsed))\n")
		sb.WriteString("\t\tarray = nxtArr\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = array\n")
	case "[]bool":
		sb.WriteString("_, array, nxt, err := jsvalues.FindArray(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := []")
		sb.WriteString(m.Type[2:])
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(array) > 0 {\n")
		sb.WriteString("\t\t_, val, nxtArr, err := jsbool.Find(array)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparsed, err := strconv.ParseBool(string(val))\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals = append(vals, ")
		sb.WriteString(m.Type[2:])
		sb.WriteString("(parsed))\n")
		sb.WriteString("\t\tarray = nxtArr\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = array\n")
	case "map[string]string":
		sb.WriteString("_, obj, nxt, err := jsvalues.FindObject(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := map[string]string{}\n")
		sb.WriteString("\tfor len(obj) > 0 {\n")
		sb.WriteString("\t\t_, key, nxtObj, err := jsstring.Find(obj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\t_, val, nxtObj, err := jsstring.Find(nxtObj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals[strings.Trim(string(key), \"\\\"\")] = strings.Trim(string(val), \"\\\"\")\n")
		sb.WriteString("\t\tobj = nxtObj\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = obj\n")
	case "map[string]int", "map[string]int8", "map[string]int16", "map[string]int32", "map[string]int64":
		sb.WriteString("_, obj, nxt, err := jsvalues.FindObject(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := ")
		sb.WriteString(m.Type)
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(obj) > 0 {\n")
		sb.WriteString("\t\t_, key, nxtObj, err := jsstring.Find(obj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\t_, val, nxtObj, err := jsnumber.Find(nxtObj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparse, err := strconv.ParseInt(string(val), 10, 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals[strings.Trim(string(key), \"\\\"\")] = ")
		sb.WriteString(m.Type[11:])
		sb.WriteString("(parse)\n")
		sb.WriteString("\t\tobj = nxtObj\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = obj\n")
	case "map[string]uint", "map[string]uint8", "map[string]uint16", "map[string]uint32", "map[string]uint64":
		sb.WriteString("_, obj, nxt, err := jsvalues.FindObject(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := ")
		sb.WriteString(m.Type)
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(obj) > 0 {\n")
		sb.WriteString("\t\t_, key, nxtObj, err := jsstring.Find(obj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\t_, val, nxtObj, err := jsnumber.Find(nxtObj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparse, err := strconv.ParseUint(string(val), 10, 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals[strings.Trim(string(key), \"\\\"\")] = ")
		sb.WriteString(m.Type[11:])
		sb.WriteString("(parse)\n")
		sb.WriteString("\t\tobj = nxtObj\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = obj\n")
	case "map[string]float32", "map[string]float64":
		sb.WriteString("_, obj, nxt, err := jsvalues.FindObject(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := ")
		sb.WriteString(m.Type)
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(obj) > 0 {\n")
		sb.WriteString("\t\t_, key, nxtObj, err := jsstring.Find(obj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\t_, val, nxtObj, err := jsnumber.Find(nxtObj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tparse, err := strconv.ParseFloat(string(val), 64)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals[strings.Trim(string(key), \"\\\"\")] = ")
		sb.WriteString(m.Type[11:])
		sb.WriteString("(parse)\n")
		sb.WriteString("\t\tobj = nxtObj\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = obj\n")
	case "map[string]bool":
		sb.WriteString("_, obj, nxt, err := jsvalues.FindObject(next)\n")
		sb.WriteString("\tif err != nil {\n")
		sb.WriteString("\t\treturn err\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\t\tnext = nxt\n")
		sb.WriteString("\tvals := ")
		sb.WriteString(m.Type)
		sb.WriteString("{}\n")
		sb.WriteString("\tfor len(obj) > 0 {\n")
		sb.WriteString("\t\t_, key, nxtObj, err := jsstring.Find(obj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\t_, val, nxtObj, err := jsbool.Find(nxtObj)\n")
		sb.WriteString("\t\tif err != nil {\n")
		sb.WriteString("\t\t\tbreak\n")
		sb.WriteString("\t\t}\n")
		sb.WriteString("\t\tvals[strings.Trim(string(key), \"\\\"\")] = ")
		sb.WriteString(m.Type[11:])
		sb.WriteString("(val)\n")
		sb.WriteString("\t\tobj = nxtObj\n")
		sb.WriteString("\t}\n")
		sb.WriteString("\tv.")
		sb.WriteString(m.Name)
		sb.WriteString(" = vals\n")
		sb.WriteString("\tnext = obj\n")
	default:
		if len(m.SubMmbers) == 0 {
			return "", errors.New("unknown type: " + m.Type)
		}
		// sb.WriteString("switch ")
		// parant = "\"\\\"\" + strings.Trim(m.Name, \"\\\"\") + \".\" + strings.Trim(parant, \"\\\"\") + \"\\\"\""
		// sb.WriteString(parant)
		// sb.WriteString(" {\n")
		// for _, v := range m.SubMmbers {
		// 	sn := strcase.SnakeToPascal(v.Name)
		// 	v.Name = "\"" + strings.Trim(m.Name, "\"") + "." + strings.Trim(sn, "\"") + "\""
		// 	s, err := GoVarFromJSON(parant, v)
		// 	if err != nil {
		// 		return "", err
		// 	}
		// 	sb.WriteString(s)
		// }
		// sb.WriteString("sb.WriteString(\" }\")\n")
	}
	return sb.String(), nil
}
